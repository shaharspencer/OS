- in spawn_utils::decide_tid ():
    - check tid is in range 0...MAX_THREADS
    - handle error code (-1)



 //

MAKE SURE NO MEMORY LEAKS OCCUR

Round-Robin Algorithm:
while(scheduler_is_running) {
    // the next thread to run is assigned to running_thread
    ret = run threads[running_thread] for quantum: // -> add run() method to Thread
        if ret == QUANTUM_ELAPSED:
            ready_threads.push(running_thread)
        else if ret == BLOCKED:
            blocked_threads.add(running_thread)
        else if ret == TERMINATED:
            terminate(running_thread)
    threads[running_thread].increment_quanta_counter()
    total_quanta_counter++;
    running_thread = ready_threads.pop()
}

void thread0 () {
    ...
    uthread_terminate(this thread's tid); // by assumption 1
    return;
}

#####

int main() {
    static sigjmp_buf _buf;
    if(sigsetjmp(_buf) != 27) {  // whenever we call siglongjmp(_buf) we will
                                    "return" here with the value we sent, first
                                     time it will return 0
        foo();
    } else {
        bar();
    }
    return 0;
}

foo() {
    siglongjmp(_buf, 27); // jump to _buf bookmark with value 27
}

bar() {
    if(sigsetjmp(_buf) == 15) {
        return;
    }
    siglongjmp(_buf, 15); // jump to _buf bookmark with value 15
}

#######

set<int> *sleeping_threads;
in timer_handler:
    for thread in sleeping:
        sleeping_time--;
        if sleeping_time == 0:
            remove from sleeping;