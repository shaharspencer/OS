shaharspencer, n318162971
Shahar Spencer (208067017), Nadav Elan Eliash (318162971)
EX: 2


FILES:
uthreads.h -- a file provided to us
uthreads.cpp -- implementations of the class
Scheduler.cpp -- a class managing the scheduling
Scheduler.h -- decelrations of methods and variables
Thread.h -- a file defining a thread
Thread.cpp - implementations of the methods


REMARKS:
These are some remarks on our implementation.

###################################
#####  THE SCHEDULER'S LOGIC  #####
###################################

From the Scheduler's perspective, the state of a thread with ID number tid is
defined by two attributes:

- The thread's associated Thread object's unique state, as could be retrieved
  using threads[tid]->get_state().
  levels: RUNNING, READY, BLOCKED
- The tid's unique location in the Scheduler's inner structures.
  levels: running_thread, ready_threads, blocked_threads, sleeping_threads

The only valid tuples are:
* (RUNNING, running_thread)
* (READY, ready_threads)
* (READY, sleeping_threads)
* (BLOCKED, blocked_threads)
* (BLOCKED, sleeping_threads)

During it's run, the Scheduler maintains the validity of these parameters by
one another and their tuple's correspondence to the thread's current desired
state.

#####################
# STATE TRANSITIONS #
#####################

* NOTE: The mark (!!) implies a scheduling event occurs *

SPAWN
=====
(*, *) --> (READY, ready_threads)

SCHEDULE
========
(READY, ready_threads) --> (RUNNING, running_thread)

BLOCK
=====
(RUNNING, running_thread) --> (BLOCKED, blocked_threads) !!
(READY, ready_threads) --> (BLOCKED, blocked_threads)
(READY, sleeping_threads) --> (BLOCKED, sleeping_threads)

RESUME
======
(BLOCKED, blocked_threads) --> (READY, ready_threads)
(BLOCKED, sleeping_threads) --> (READY, sleeping_threads)

SLEEP
=====
(RUNNING, running_thread) --> (READY, sleeping_threads) !!

WAKE-UP
=======
(READY, sleeping_threads) --> (READY, ready_threads)
(BLOCKED, sleeping_threads) --> (BLOCKED, blocked_threads)

TERMINATE
=========
(RUNNING, running_thread) --> (*, *) !!
(READY, ready_threads) --> (*, *)
(READY, sleeping_threads) --> (*, *)
(BLOCKED, blocked_threads) --> (*, *)
(BLOCKED, sleeping_threads) --> (*, *)

######################################

Part 1: Theoretical Questions (10 pts)

1. Siglongjmp and sigsetjmp:
===

a. Describe what the functions sigsetjmp and siglongjmp do.
===
sigsetjmp saves the current state of a process or thread so that we can return to that state later using siglongjmp.
When we have asynchronous events, such as signals, we need to be able to stop the execution of the process at an
undetermined point and be able to return to that same point later.
siglongjmp is used to return to a previously set point in a process or thread that was set via sigsetjmp.

b. Describe how sigsetjmp and siglongjmp affect masking.
===
These functions save and restore the current signal mask, which decides which signals can and cannot
interrupt our programme.
sigsetjmp saves the current signal mask, and when siglongjmp is called we restore that state.
Any other signals received during execution will be blocked and added to a queue of signals waiting to be handled.

2. Describe one general use of user-level threads and explain why user-level threads are a
reasonable choice for your example.
===
We can use user-level threads to allow execution of multiple tasks within one process, without relying on the operating
system to do the context switches for us. We will do this to have more control over the programme or because the
overhead time of using the kernel-level threads is too high.
One general use of user-level threads is in multimedia applications which have to execute many tasks at once, for
example: playing a video while applying a filter to it and adding subtitles.
We can therefore manage these tasks at our own level, without the overhead of kernel-level threads, and thus improve
the runtime of the programme.

3. Google’s Chrome browser creates a new process for each tab. What are the advantages
and disadvantages of creating the new process (instead of creating a kernel-level
thread)?
===
Advantages:
- If one tab crashes this does not affect the other tabs as they are in different processes.
- We improve security as one tab cannot access other tabs' data.
- We can improve overall performance by distributing the load of running these tabs by taking advantage
of multi-core CPUs.

Disadvantages:
- The creation of multiple processes requires overhead for creating each process and can take longer time to manage
communication between processes than threads in the same process.

4. Interrupts and signals:
===

a. Open an application (for example, “Shotwell” on one of the CS computers). Use
the “ps -A” command to extract the application’s pid (process ID).
==
lyx is open with pid 227462

b. Open a shell and type “kill pid”.
===
lyx is now terminated

c. Explain which interrupts and signals are involved during the command execution,
what triggered them and who should handle them. In your answer, refer to the
keyboard, OS, shell, and the application you just killed.
===
With each type of a key on the keyboard while typing the command to the terminal, a hardware interrupt occurs that
triggers te operating system to handle our input.
Upon hitting the enter key, another interrupt from the keyboard is mediated by the operating system to make the shell
process to read the command and generate a SIGKILL signal to the lyx process with the pid 227462.
The operating system then delivers the signal to the target lyx process, which can either handle or ignore it.
If the lyx process does not handle the signal, the default signal handler is executed, which terminates the execution
of the process and releases its resources, as indeed happened.
Once the signal has been handled or ignored by the target process, a signal acknowledgement is sent back to the
operating system.

5. What is the difference between ‘real’ and ‘virtual’ time? Give one example of using each.
===
Real time refers to the actual time that has passed (in seconds, milliseconds etc).
Virtual time is independent of the actual time that has passed and is actually simulated time.
Real time is used in a race when we want to measure how fast each contestant ran.
Virtual time is used to measure the time a function takes regardless of, for example,
system load and different hardware concerns.
